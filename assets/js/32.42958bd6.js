(window.webpackJsonp=window.webpackJsonp||[]).push([[32],{270:function(a,t,r){a.exports=r.p+"assets/img/j4.9cd59d39.jpg"},349:function(a,t,r){"use strict";r.r(t);var _=r(30),s=Object(_.a)({},(function(){var a=this,t=a.$createElement,_=a._self._c||t;return _("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[_("h1",{attrs:{id:"编写高质量-javascript-的-68-个有效方法"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#编写高质量-javascript-的-68-个有效方法"}},[a._v("#")]),a._v(" 编写高质量 JavaScript 的 68 个有效方法")]),a._v(" "),_("p",[_("img",{attrs:{src:r(270),alt:"编写高质量 JavaScript 的 68 个有效方法"}})]),_("div",{staticClass:"table-of-contents"},[_("ul",[_("li",[_("a",{attrs:{href:"#第1章-让自己习惯-javascript"}},[a._v("第1章. 让自己习惯 JavaScript")]),_("ul",[_("li",[_("a",{attrs:{href:"#_1-了解你使用的-javascript-版本"}},[a._v("1.了解你使用的 JavaScript 版本")])]),_("li",[_("a",{attrs:{href:"#_2-理解-javascript-的浮点数"}},[a._v("2.理解 JavaScript 的浮点数")])]),_("li",[_("a",{attrs:{href:"#_3-当心隐式的强制转换"}},[a._v("3.当心隐式的强制转换")])]),_("li",[_("a",{attrs:{href:"#_4-原始类型优于封装对象"}},[a._v("4.原始类型优于封装对象")])]),_("li",[_("a",{attrs:{href:"#_5-避免对混合类型使用-运算符"}},[a._v("5.避免对混合类型使用===运算符")])]),_("li",[_("a",{attrs:{href:"#_6-了解分号插入的局限"}},[a._v("6.了解分号插入的局限")])]),_("li",[_("a",{attrs:{href:"#_7-视字符串为-16-位的代码单元序列"}},[a._v("7.视字符串为 16 位的代码单元序列")])])])]),_("li",[_("a",{attrs:{href:"#第2章-变量作用域"}},[a._v("第2章. 变量作用域")]),_("ul",[_("li",[_("a",{attrs:{href:"#_8-尽量少用全局对象"}},[a._v("8.尽量少用全局对象")])]),_("li",[_("a",{attrs:{href:"#_9-始终声明局部变量"}},[a._v("9.始终声明局部变量")])]),_("li",[_("a",{attrs:{href:"#_10-避免使用-with"}},[a._v("10.避免使用 with")])]),_("li",[_("a",{attrs:{href:"#_11-熟练掌握闭包"}},[a._v("11.熟练掌握闭包")])]),_("li",[_("a",{attrs:{href:"#_12-理解变量声明提升"}},[a._v("12.理解变量声明提升")])]),_("li",[_("a",{attrs:{href:"#_13-使用立即调用的函数表达式创建局部作用域"}},[a._v("13.使用立即调用的函数表达式创建局部作用域")])]),_("li",[_("a",{attrs:{href:"#_14-当心命名函数表达式笨拙的作用域"}},[a._v("14.当心命名函数表达式笨拙的作用域")])]),_("li",[_("a",{attrs:{href:"#_15-当心局部函数声明笨拙的作用域"}},[a._v("15.当心局部函数声明笨拙的作用域")])]),_("li",[_("a",{attrs:{href:"#_16-避免使用-eval-创建局部变量"}},[a._v("16.避免使用 eval 创建局部变量")])]),_("li",[_("a",{attrs:{href:"#_17-间接调用-eval-函数优于直接调用"}},[a._v("17.间接调用 eval 函数优于直接调用")])])])]),_("li",[_("a",{attrs:{href:"#第3章-使用函数"}},[a._v("第3章. 使用函数")]),_("ul",[_("li",[_("a",{attrs:{href:"#_18-理解函数调用、方法调用及构造函数调用之间的不同"}},[a._v("18.理解函数调用、方法调用及构造函数调用之间的不同")])]),_("li",[_("a",{attrs:{href:"#_19-熟练掌握高阶函数"}},[a._v("19.熟练掌握高阶函数")])]),_("li",[_("a",{attrs:{href:"#_20-使用-call-方法自定义接受者来调用方法"}},[a._v("20.使用 call 方法自定义接受者来调用方法")])]),_("li",[_("a",{attrs:{href:"#_21-使用-apply-方法通过不同数量的参数调用函数"}},[a._v("21.使用 apply 方法通过不同数量的参数调用函数")])]),_("li",[_("a",{attrs:{href:"#_23-永远不要修改-arguments-对象"}},[a._v("23.永远不要修改 arguments 对象")])]),_("li",[_("a",{attrs:{href:"#_24-使用变量保存-arguments-的引用"}},[a._v("24.使用变量保存 arguments 的引用")])]),_("li",[_("a",{attrs:{href:"#_25-使用-bind-方法提取具有确定接收者的方法"}},[a._v("25.使用 bind 方法提取具有确定接收者的方法")])]),_("li",[_("a",{attrs:{href:"#_26-使用-bind-方法实现函数柯里化"}},[a._v("26.使用 bind 方法实现函数柯里化")])]),_("li",[_("a",{attrs:{href:"#_27-使用闭包而不是字符串来封装代码"}},[a._v("27.使用闭包而不是字符串来封装代码")])]),_("li",[_("a",{attrs:{href:"#_28-不要信任函数对象的-tostring-方法"}},[a._v("28.不要信任函数对象的 toString 方法")])]),_("li",[_("a",{attrs:{href:"#_29-避免使用非标准的栈检查属性"}},[a._v("29.避免使用非标准的栈检查属性")])])])]),_("li",[_("a",{attrs:{href:"#第4章-对象和原型"}},[a._v("第4章. 对象和原型")]),_("ul",[_("li",[_("a",{attrs:{href:"#_30-理解-prototype、getprototypeof-和-proto-之间的不同"}},[a._v("30.理解 prototype、getPrototypeOf 和proto之间的不同")])]),_("li",[_("a",{attrs:{href:"#_31-使用-object-getprototypeof-函数而不要使用-proto-属性"}},[a._v("31.使用 Object.getPrototypeOf 函数而不要使用proto属性")])]),_("li",[_("a",{attrs:{href:"#_32-始终不要修改-proto-属性"}},[a._v("32.始终不要修改proto属性")])]),_("li",[_("a",{attrs:{href:"#_33-使用构造函数与-new-方法无关"}},[a._v("33.使用构造函数与 new 方法无关")])]),_("li",[_("a",{attrs:{href:"#_34-在原型中存储方法"}},[a._v("34.在原型中存储方法")])]),_("li",[_("a",{attrs:{href:"#_35-使用闭包存储私有数据"}},[a._v("35.使用闭包存储私有数据")])]),_("li",[_("a",{attrs:{href:"#_36-只将实力状态存储在实例对象中"}},[a._v("36.只将实力状态存储在实例对象中")])]),_("li",[_("a",{attrs:{href:"#_37-认识到-this-变量的隐式绑定问题"}},[a._v("37.认识到 this 变量的隐式绑定问题")])]),_("li",[_("a",{attrs:{href:"#_38-在子类的构造函数中调用父类的构造函数"}},[a._v("38.在子类的构造函数中调用父类的构造函数")])]),_("li",[_("a",{attrs:{href:"#_39-不要重用父类的属性名"}},[a._v("39.不要重用父类的属性名")])]),_("li",[_("a",{attrs:{href:"#_40-避免继承标准类"}},[a._v("40.避免继承标准类")])]),_("li",[_("a",{attrs:{href:"#_41-将原型视为实现细节"}},[a._v("41.将原型视为实现细节")])]),_("li",[_("a",{attrs:{href:"#_42-避免使用轻率的猴子补丁"}},[a._v("42.避免使用轻率的猴子补丁")])])])]),_("li",[_("a",{attrs:{href:"#第5章-数组和字典"}},[a._v("第5章. 数组和字典")]),_("ul",[_("li",[_("a",{attrs:{href:"#_43-使用-object-的直接实例构造轻量级的字典"}},[a._v("43.使用 Object 的直接实例构造轻量级的字典")])]),_("li",[_("a",{attrs:{href:"#_44-使用-null-原型以防止原型污染"}},[a._v("44.使用 null 原型以防止原型污染")])]),_("li",[_("a",{attrs:{href:"#_45-使用-hasownproperty-方法"}},[a._v("45.使用 hasOwnProperty 方法")])]),_("li",[_("a",{attrs:{href:"#_46-使用数组而不要使用字典来存储有序集合"}},[a._v("46.使用数组而不要使用字典来存储有序集合")])]),_("li",[_("a",{attrs:{href:"#_47-绝不要在-object-prototype-中增加可枚举的属性"}},[a._v("47.绝不要在 Object.prototype 中增加可枚举的属性")])]),_("li",[_("a",{attrs:{href:"#_48-避免在枚举期间修改对象"}},[a._v("48.避免在枚举期间修改对象")])]),_("li",[_("a",{attrs:{href:"#_49-数组迭代要优先使用-for-循环而不是-for-in-循环"}},[a._v("49.数组迭代要优先使用 for 循环而不是 for..in 循环")])]),_("li",[_("a",{attrs:{href:"#_50-迭代方法优于循环"}},[a._v("50.迭代方法优于循环")])]),_("li",[_("a",{attrs:{href:"#_51-在类数组对象上服用通用的数组方法"}},[a._v("51.在类数组对象上服用通用的数组方法")])]),_("li",[_("a",{attrs:{href:"#_52-数组字面量优于数组构造函数"}},[a._v("52.数组字面量优于数组构造函数")])])])]),_("li",[_("a",{attrs:{href:"#第6章-库和-api-设计"}},[a._v("第6章. 库和 API 设计")]),_("ul",[_("li",[_("a",{attrs:{href:"#_53-保持一致的约定"}},[a._v("53.保持一致的约定")])]),_("li",[_("a",{attrs:{href:"#_54-将-undefined-看作-没有值"}},[a._v('54.将 undefined 看作"没有值"')])]),_("li",[_("a",{attrs:{href:"#_55-接收关键字参数的选项对象"}},[a._v("55.接收关键字参数的选项对象")])]),_("li",[_("a",{attrs:{href:"#_56-避免不必要的状态"}},[a._v("56.避免不必要的状态")])]),_("li",[_("a",{attrs:{href:"#_57-使用结构类型设计灵活的接口"}},[a._v("57.使用结构类型设计灵活的接口")])]),_("li",[_("a",{attrs:{href:"#_58-区分数组对象和类数组对象"}},[a._v("58.区分数组对象和类数组对象")])]),_("li",[_("a",{attrs:{href:"#_59-避免过度的强制转换"}},[a._v("59.避免过度的强制转换")])]),_("li",[_("a",{attrs:{href:"#_60-支持方法链"}},[a._v("60.支持方法链")])])])]),_("li",[_("a",{attrs:{href:"#第7章-并发"}},[a._v("第7章. 并发")]),_("ul",[_("li",[_("a",{attrs:{href:"#_61-不要阻塞-i-o-事件队列"}},[a._v("61.不要阻塞 I/O 事件队列")])]),_("li",[_("a",{attrs:{href:"#_62-在异步序列中使用嵌套或命名的回调函数"}},[a._v("62.在异步序列中使用嵌套或命名的回调函数")])]),_("li",[_("a",{attrs:{href:"#_63-当心丢弃错误"}},[a._v("63.当心丢弃错误")])]),_("li",[_("a",{attrs:{href:"#_64-对异步循环使用递归"}},[a._v("64.对异步循环使用递归")])]),_("li",[_("a",{attrs:{href:"#_65-不要在计算时阻塞事件队列"}},[a._v("65.不要在计算时阻塞事件队列")])]),_("li",[_("a",{attrs:{href:"#_66-使用计数器来执行并行操作"}},[a._v("66.使用计数器来执行并行操作")])]),_("li",[_("a",{attrs:{href:"#_67-绝不要同步地调用异步的回调函数"}},[a._v("67.绝不要同步地调用异步的回调函数")])]),_("li",[_("a",{attrs:{href:"#_68-使用-promise-模式清洁异步逻辑"}},[a._v("68.使用 promise 模式清洁异步逻辑")])])])])])]),_("p"),a._v(" "),_("h2",{attrs:{id:"第1章-让自己习惯-javascript"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#第1章-让自己习惯-javascript"}},[a._v("#")]),a._v(" 第1章. 让自己习惯 JavaScript")]),a._v(" "),_("p",[a._v("JavaScript最初设计令人感觉亲切。由于其语法让人联想到Java，并且具有许多脚本语言的共同特性（如函数、数组、字典和正则表达式），因此，具有少量编程经验的人也能够快速学习JavaScript。新手程序员几乎不需要培训就可以开始编写程序，这要归功于JavaScript语言提供的为数不多的核心概念。")]),a._v(" "),_("p",[a._v("虽然JavaScript是如此的平易近人，但是精通这门语言需要更多的时间，需要更深入地理解它的语义、特性以及最有效的习惯用法。本书每个章节都涵盖了高效JavaScript编程的不同主题。第1章讲述一些最基本的主题。")]),a._v(" "),_("h3",{attrs:{id:"_1-了解你使用的-javascript-版本"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-了解你使用的-javascript-版本"}},[a._v("#")]),a._v(" 1.了解你使用的 JavaScript 版本")]),a._v(" "),_("h3",{attrs:{id:"_2-理解-javascript-的浮点数"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-理解-javascript-的浮点数"}},[a._v("#")]),a._v(" 2.理解 JavaScript 的浮点数")]),a._v(" "),_("h3",{attrs:{id:"_3-当心隐式的强制转换"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-当心隐式的强制转换"}},[a._v("#")]),a._v(" 3.当心隐式的强制转换")]),a._v(" "),_("h3",{attrs:{id:"_4-原始类型优于封装对象"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_4-原始类型优于封装对象"}},[a._v("#")]),a._v(" 4.原始类型优于封装对象")]),a._v(" "),_("h3",{attrs:{id:"_5-避免对混合类型使用-运算符"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_5-避免对混合类型使用-运算符"}},[a._v("#")]),a._v(" 5.避免对混合类型使用===运算符")]),a._v(" "),_("h3",{attrs:{id:"_6-了解分号插入的局限"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_6-了解分号插入的局限"}},[a._v("#")]),a._v(" 6.了解分号插入的局限")]),a._v(" "),_("h3",{attrs:{id:"_7-视字符串为-16-位的代码单元序列"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_7-视字符串为-16-位的代码单元序列"}},[a._v("#")]),a._v(" 7.视字符串为 16 位的代码单元序列")]),a._v(" "),_("h2",{attrs:{id:"第2章-变量作用域"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#第2章-变量作用域"}},[a._v("#")]),a._v(" 第2章. 变量作用域")]),a._v(" "),_("p",[a._v("作用域对于程序员来说就像氧气。它无处不在，甚至，你往往不会去特意想它。但当它被污染时，你会感觉到窒息。")]),a._v(" "),_("p",[a._v("好消息是JavaScript核心的作用域规则很简单。其作用域规则被精心设计，且强大得令人难以置信；但也有一些例外。有效地使用JavaScript需要掌握变量作用域的一些基本概念，并了解一些可能导致难以捉摸又令人生疑的极端情况。")]),a._v(" "),_("h3",{attrs:{id:"_8-尽量少用全局对象"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_8-尽量少用全局对象"}},[a._v("#")]),a._v(" 8.尽量少用全局对象")]),a._v(" "),_("h3",{attrs:{id:"_9-始终声明局部变量"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_9-始终声明局部变量"}},[a._v("#")]),a._v(" 9.始终声明局部变量")]),a._v(" "),_("h3",{attrs:{id:"_10-避免使用-with"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_10-避免使用-with"}},[a._v("#")]),a._v(" 10.避免使用 with")]),a._v(" "),_("h3",{attrs:{id:"_11-熟练掌握闭包"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_11-熟练掌握闭包"}},[a._v("#")]),a._v(" 11.熟练掌握闭包")]),a._v(" "),_("h3",{attrs:{id:"_12-理解变量声明提升"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_12-理解变量声明提升"}},[a._v("#")]),a._v(" 12.理解变量声明提升")]),a._v(" "),_("h3",{attrs:{id:"_13-使用立即调用的函数表达式创建局部作用域"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_13-使用立即调用的函数表达式创建局部作用域"}},[a._v("#")]),a._v(" 13.使用立即调用的函数表达式创建局部作用域")]),a._v(" "),_("h3",{attrs:{id:"_14-当心命名函数表达式笨拙的作用域"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_14-当心命名函数表达式笨拙的作用域"}},[a._v("#")]),a._v(" 14.当心命名函数表达式笨拙的作用域")]),a._v(" "),_("h3",{attrs:{id:"_15-当心局部函数声明笨拙的作用域"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_15-当心局部函数声明笨拙的作用域"}},[a._v("#")]),a._v(" 15.当心局部函数声明笨拙的作用域")]),a._v(" "),_("h3",{attrs:{id:"_16-避免使用-eval-创建局部变量"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_16-避免使用-eval-创建局部变量"}},[a._v("#")]),a._v(" 16.避免使用 eval 创建局部变量")]),a._v(" "),_("h3",{attrs:{id:"_17-间接调用-eval-函数优于直接调用"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_17-间接调用-eval-函数优于直接调用"}},[a._v("#")]),a._v(" 17.间接调用 eval 函数优于直接调用")]),a._v(" "),_("h2",{attrs:{id:"第3章-使用函数"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#第3章-使用函数"}},[a._v("#")]),a._v(" 第3章. 使用函数")]),a._v(" "),_("p",[a._v("函数是JavaScript中的“第一公民”，既给程序员提供了一些主要的抽象功能，又提供了实现机制。函数可以独自实现其他语言中的多个不同特性，例如：过程、方法、构造函数，甚至类和模块。一旦你熟悉了函数的具体细节，你就掌握了JavaScript的重要组成部分。然而凡事都有两面性，学会在不同的环境中高效地使用函数是需要下一番功夫的。")]),a._v(" "),_("h3",{attrs:{id:"_18-理解函数调用、方法调用及构造函数调用之间的不同"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_18-理解函数调用、方法调用及构造函数调用之间的不同"}},[a._v("#")]),a._v(" 18.理解函数调用、方法调用及构造函数调用之间的不同")]),a._v(" "),_("h3",{attrs:{id:"_19-熟练掌握高阶函数"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_19-熟练掌握高阶函数"}},[a._v("#")]),a._v(" 19.熟练掌握高阶函数")]),a._v(" "),_("h3",{attrs:{id:"_20-使用-call-方法自定义接受者来调用方法"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_20-使用-call-方法自定义接受者来调用方法"}},[a._v("#")]),a._v(" 20.使用 call 方法自定义接受者来调用方法")]),a._v(" "),_("h3",{attrs:{id:"_21-使用-apply-方法通过不同数量的参数调用函数"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_21-使用-apply-方法通过不同数量的参数调用函数"}},[a._v("#")]),a._v(" 21.使用 apply 方法通过不同数量的参数调用函数")]),a._v(" "),_("h3",{attrs:{id:"_23-永远不要修改-arguments-对象"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_23-永远不要修改-arguments-对象"}},[a._v("#")]),a._v(" 23.永远不要修改 arguments 对象")]),a._v(" "),_("h3",{attrs:{id:"_24-使用变量保存-arguments-的引用"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_24-使用变量保存-arguments-的引用"}},[a._v("#")]),a._v(" 24.使用变量保存 arguments 的引用")]),a._v(" "),_("h3",{attrs:{id:"_25-使用-bind-方法提取具有确定接收者的方法"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_25-使用-bind-方法提取具有确定接收者的方法"}},[a._v("#")]),a._v(" 25.使用 bind 方法提取具有确定接收者的方法")]),a._v(" "),_("h3",{attrs:{id:"_26-使用-bind-方法实现函数柯里化"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_26-使用-bind-方法实现函数柯里化"}},[a._v("#")]),a._v(" 26.使用 bind 方法实现函数柯里化")]),a._v(" "),_("h3",{attrs:{id:"_27-使用闭包而不是字符串来封装代码"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_27-使用闭包而不是字符串来封装代码"}},[a._v("#")]),a._v(" 27.使用闭包而不是字符串来封装代码")]),a._v(" "),_("h3",{attrs:{id:"_28-不要信任函数对象的-tostring-方法"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_28-不要信任函数对象的-tostring-方法"}},[a._v("#")]),a._v(" 28.不要信任函数对象的 toString 方法")]),a._v(" "),_("h3",{attrs:{id:"_29-避免使用非标准的栈检查属性"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_29-避免使用非标准的栈检查属性"}},[a._v("#")]),a._v(" 29.避免使用非标准的栈检查属性")]),a._v(" "),_("h2",{attrs:{id:"第4章-对象和原型"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#第4章-对象和原型"}},[a._v("#")]),a._v(" 第4章. 对象和原型")]),a._v(" "),_("p",[a._v("对象是JavaScript中的基本数据结构。直观的看，对象表示字符串与值映射的一个表格。但当你深入挖掘时，你会发行对象中有相当多的体系。")]),a._v(" "),_("p",[a._v("与许多面向对象的语言一样，JavaScript支持继承，即通过动态代理机制重用代码或数据。但和其他许多传统的语言不同的是，JavaScript的继承机制基于原型，而不是类。对于许多程序员来说，JavaScript是第一个不需要类而实现面向对象的语言。")]),a._v(" "),_("p",[a._v("在许多语言中，每个对象是相关类的实例，该类提供在其所有实例间共享属性和方法。相反，JavaScript并没有类的内置概念，对象是从其它对象中继承而来。每个对象与其它一些对象是相关的，这些对象称为它的原型。尽管依然使用了很多传统的面向对象语言的概念，但使用原型与使用类有很大差异。")]),a._v(" "),_("h3",{attrs:{id:"_30-理解-prototype、getprototypeof-和proto之间的不同"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_30-理解-prototype、getprototypeof-和proto之间的不同"}},[a._v("#")]),a._v(" 30.理解 prototype、getPrototypeOf 和"),_("strong",[a._v("proto")]),a._v("之间的不同")]),a._v(" "),_("h3",{attrs:{id:"_31-使用-object-getprototypeof-函数而不要使用proto属性"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_31-使用-object-getprototypeof-函数而不要使用proto属性"}},[a._v("#")]),a._v(" 31.使用 Object.getPrototypeOf 函数而不要使用"),_("strong",[a._v("proto")]),a._v("属性")]),a._v(" "),_("h3",{attrs:{id:"_32-始终不要修改proto属性"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_32-始终不要修改proto属性"}},[a._v("#")]),a._v(" 32.始终不要修改"),_("strong",[a._v("proto")]),a._v("属性")]),a._v(" "),_("h3",{attrs:{id:"_33-使用构造函数与-new-方法无关"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_33-使用构造函数与-new-方法无关"}},[a._v("#")]),a._v(" 33.使用构造函数与 new 方法无关")]),a._v(" "),_("h3",{attrs:{id:"_34-在原型中存储方法"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_34-在原型中存储方法"}},[a._v("#")]),a._v(" 34.在原型中存储方法")]),a._v(" "),_("h3",{attrs:{id:"_35-使用闭包存储私有数据"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_35-使用闭包存储私有数据"}},[a._v("#")]),a._v(" 35.使用闭包存储私有数据")]),a._v(" "),_("h3",{attrs:{id:"_36-只将实力状态存储在实例对象中"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_36-只将实力状态存储在实例对象中"}},[a._v("#")]),a._v(" 36.只将实力状态存储在实例对象中")]),a._v(" "),_("h3",{attrs:{id:"_37-认识到-this-变量的隐式绑定问题"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_37-认识到-this-变量的隐式绑定问题"}},[a._v("#")]),a._v(" 37.认识到 this 变量的隐式绑定问题")]),a._v(" "),_("h3",{attrs:{id:"_38-在子类的构造函数中调用父类的构造函数"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_38-在子类的构造函数中调用父类的构造函数"}},[a._v("#")]),a._v(" 38.在子类的构造函数中调用父类的构造函数")]),a._v(" "),_("h3",{attrs:{id:"_39-不要重用父类的属性名"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_39-不要重用父类的属性名"}},[a._v("#")]),a._v(" 39.不要重用父类的属性名")]),a._v(" "),_("h3",{attrs:{id:"_40-避免继承标准类"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_40-避免继承标准类"}},[a._v("#")]),a._v(" 40.避免继承标准类")]),a._v(" "),_("h3",{attrs:{id:"_41-将原型视为实现细节"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_41-将原型视为实现细节"}},[a._v("#")]),a._v(" 41.将原型视为实现细节")]),a._v(" "),_("h3",{attrs:{id:"_42-避免使用轻率的猴子补丁"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_42-避免使用轻率的猴子补丁"}},[a._v("#")]),a._v(" 42.避免使用轻率的猴子补丁")]),a._v(" "),_("h2",{attrs:{id:"第5章-数组和字典"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#第5章-数组和字典"}},[a._v("#")]),a._v(" 第5章. 数组和字典")]),a._v(" "),_("p",[a._v("对象是JavaScript中最万能的数据结构。取决于不同的环境，对象可以表示一个灵活的键值关联记录，一个继承了方法的面向对象数据抽象，一个密集或稀疏的数组，或一个散列表。当然，使用这一多用途的工具需要掌握针对不同需求的不同惯用法。在上一章中，我们学习了结构对象和继承的用法。在本章中，我们来解决将对象作为集合（比如不同树木元素的聚合数据结构）的方法。")]),a._v(" "),_("h3",{attrs:{id:"_43-使用-object-的直接实例构造轻量级的字典"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_43-使用-object-的直接实例构造轻量级的字典"}},[a._v("#")]),a._v(" 43.使用 Object 的直接实例构造轻量级的字典")]),a._v(" "),_("h3",{attrs:{id:"_44-使用-null-原型以防止原型污染"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_44-使用-null-原型以防止原型污染"}},[a._v("#")]),a._v(" 44.使用 null 原型以防止原型污染")]),a._v(" "),_("h3",{attrs:{id:"_45-使用-hasownproperty-方法"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_45-使用-hasownproperty-方法"}},[a._v("#")]),a._v(" 45.使用 hasOwnProperty 方法")]),a._v(" "),_("h3",{attrs:{id:"_46-使用数组而不要使用字典来存储有序集合"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_46-使用数组而不要使用字典来存储有序集合"}},[a._v("#")]),a._v(" 46.使用数组而不要使用字典来存储有序集合")]),a._v(" "),_("h3",{attrs:{id:"_47-绝不要在-object-prototype-中增加可枚举的属性"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_47-绝不要在-object-prototype-中增加可枚举的属性"}},[a._v("#")]),a._v(" 47.绝不要在 Object.prototype 中增加可枚举的属性")]),a._v(" "),_("h3",{attrs:{id:"_48-避免在枚举期间修改对象"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_48-避免在枚举期间修改对象"}},[a._v("#")]),a._v(" 48.避免在枚举期间修改对象")]),a._v(" "),_("h3",{attrs:{id:"_49-数组迭代要优先使用-for-循环而不是-for-in-循环"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_49-数组迭代要优先使用-for-循环而不是-for-in-循环"}},[a._v("#")]),a._v(" 49.数组迭代要优先使用 for 循环而不是 for..in 循环")]),a._v(" "),_("h3",{attrs:{id:"_50-迭代方法优于循环"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_50-迭代方法优于循环"}},[a._v("#")]),a._v(" 50.迭代方法优于循环")]),a._v(" "),_("h3",{attrs:{id:"_51-在类数组对象上服用通用的数组方法"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_51-在类数组对象上服用通用的数组方法"}},[a._v("#")]),a._v(" 51.在类数组对象上服用通用的数组方法")]),a._v(" "),_("h3",{attrs:{id:"_52-数组字面量优于数组构造函数"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_52-数组字面量优于数组构造函数"}},[a._v("#")]),a._v(" 52.数组字面量优于数组构造函数")]),a._v(" "),_("h2",{attrs:{id:"第6章-库和-api-设计"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#第6章-库和-api-设计"}},[a._v("#")]),a._v(" 第6章. 库和 API 设计")]),a._v(" "),_("p",[a._v("从某种意义上讲，每个程序员都是API设计者。也许你并未计划立即写下一个流行的JavaScript库，但当你的程序已经在一个平台上运行足够长的时间，你对常见问题建立了完善的解决方案，迟早你会开始开发可重用的程序和组件。即使你没有将其发布为单独的库，提升自己的技能成为一个库作者能让你编写更好的组件。")]),a._v(" "),_("p",[a._v("设计程序是一个棘手的业务，更多的表现为科学艺术，这是非常重要的。API是程序员的基本词汇。设计良好的API能让你的用户（这可能包括你自己）清楚、简洁和明确地表达自己的程序。")]),a._v(" "),_("h3",{attrs:{id:"_53-保持一致的约定"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_53-保持一致的约定"}},[a._v("#")]),a._v(" 53.保持一致的约定")]),a._v(" "),_("h3",{attrs:{id:"_54-将-undefined-看作-没有值"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_54-将-undefined-看作-没有值"}},[a._v("#")]),a._v(' 54.将 undefined 看作"没有值"')]),a._v(" "),_("h3",{attrs:{id:"_55-接收关键字参数的选项对象"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_55-接收关键字参数的选项对象"}},[a._v("#")]),a._v(" 55.接收关键字参数的选项对象")]),a._v(" "),_("h3",{attrs:{id:"_56-避免不必要的状态"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_56-避免不必要的状态"}},[a._v("#")]),a._v(" 56.避免不必要的状态")]),a._v(" "),_("h3",{attrs:{id:"_57-使用结构类型设计灵活的接口"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_57-使用结构类型设计灵活的接口"}},[a._v("#")]),a._v(" 57.使用结构类型设计灵活的接口")]),a._v(" "),_("h3",{attrs:{id:"_58-区分数组对象和类数组对象"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_58-区分数组对象和类数组对象"}},[a._v("#")]),a._v(" 58.区分数组对象和类数组对象")]),a._v(" "),_("h3",{attrs:{id:"_59-避免过度的强制转换"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_59-避免过度的强制转换"}},[a._v("#")]),a._v(" 59.避免过度的强制转换")]),a._v(" "),_("h3",{attrs:{id:"_60-支持方法链"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_60-支持方法链"}},[a._v("#")]),a._v(" 60.支持方法链")]),a._v(" "),_("h2",{attrs:{id:"第7章-并发"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#第7章-并发"}},[a._v("#")]),a._v(" 第7章. 并发")]),a._v(" "),_("p",[a._v("JavaScript被设计为一种嵌入式的脚本语言。JavaScript程序不是以单独的应用程序运行，而是作为大型应用程序下的脚本运行。典型的例子当然是Web浏览器。一个浏览器可能具有许多窗体和标签运行多个Web应用程序，每个应用程序相应不同的输入和触发源--用户通过键盘、鼠标、触摸板的动作，来自网络的数据传输，或定时告警。这些事件可能在Web应用程序的生命周期的任何时刻发生，甚至同时发生。针对每种事件，应用程序可能希望得到消息通知，并相应自定义行为。")]),a._v(" "),_("p",[a._v("在JavaScript中，编写响应多个并发事件的程序的方法非常人性化，而且强大，因为它使用了一个简单的执行模型（有时称为事件队列或事件循环并发）和被称为异步的API。多亏了这一方法的有效性以及JavaScript独立于Web浏览器标准化的事实，使得JavaScript成为其它多种应用程序的编程语言，比如从桌面端应用程序到服务端框架的Node.js。")]),a._v(" "),_("p",[a._v("奇怪的是，到目前为止，ECMAScript标准从来没有关于并发的任何说明。因此，本章将讨论一些“约定俗成”的JavaScript特性，而不是官方的标准。然而，绝大多数JavaScript的环境都使用相同的并发策略，未来标准的版本很有可能会基于广泛实现的执行模型来标准化。不管标准如何定义，使用事件和异步API是JavaScript编程的基础部分。")]),a._v(" "),_("h3",{attrs:{id:"_61-不要阻塞-i-o-事件队列"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_61-不要阻塞-i-o-事件队列"}},[a._v("#")]),a._v(" 61.不要阻塞 I/O 事件队列")]),a._v(" "),_("h3",{attrs:{id:"_62-在异步序列中使用嵌套或命名的回调函数"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_62-在异步序列中使用嵌套或命名的回调函数"}},[a._v("#")]),a._v(" 62.在异步序列中使用嵌套或命名的回调函数")]),a._v(" "),_("h3",{attrs:{id:"_63-当心丢弃错误"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_63-当心丢弃错误"}},[a._v("#")]),a._v(" 63.当心丢弃错误")]),a._v(" "),_("h3",{attrs:{id:"_64-对异步循环使用递归"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_64-对异步循环使用递归"}},[a._v("#")]),a._v(" 64.对异步循环使用递归")]),a._v(" "),_("h3",{attrs:{id:"_65-不要在计算时阻塞事件队列"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_65-不要在计算时阻塞事件队列"}},[a._v("#")]),a._v(" 65.不要在计算时阻塞事件队列")]),a._v(" "),_("h3",{attrs:{id:"_66-使用计数器来执行并行操作"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_66-使用计数器来执行并行操作"}},[a._v("#")]),a._v(" 66.使用计数器来执行并行操作")]),a._v(" "),_("h3",{attrs:{id:"_67-绝不要同步地调用异步的回调函数"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_67-绝不要同步地调用异步的回调函数"}},[a._v("#")]),a._v(" 67.绝不要同步地调用异步的回调函数")]),a._v(" "),_("h3",{attrs:{id:"_68-使用-promise-模式清洁异步逻辑"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_68-使用-promise-模式清洁异步逻辑"}},[a._v("#")]),a._v(" 68.使用 promise 模式清洁异步逻辑")])])}),[],!1,null,null,null);t.default=s.exports}}]);